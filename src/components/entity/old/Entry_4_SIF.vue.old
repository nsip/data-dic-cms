<template>
    <div class="com">
        <span class="label">{{ label }}</span>
        <button class="hide-editor" @click="onToggleVisible()">
            <font-awesome-icon :icon="icon" />
        </button>
        <button class="less-editor" @click="onMoreLessClick('-')">
            <font-awesome-icon icon="circle-minus" />
        </button>
        <button class="more-editor" @click="onMoreLessClick('+')">
            <font-awesome-icon icon="circle-plus" />
        </button>
        <span class="hint2">{{ hint }}</span>
        <div v-if="visEditor" v-for="(n, iGrp) in editorCount" :key="iGrp">
            <hr />
            &nbsp;# {{ iGrp }}
            <QuillEditor theme="snow" toolbar="essential" placeholder="list of xpath" @ready="onReady" @textChange="textChange(iGrp, 0)" />
            <hr class="subline" />
            <QuillEditor theme="snow" toolbar="essential" placeholder="definition" @ready="onReady" @textChange="textChange(iGrp, 1)" />
            <hr class="subline" />
            <QuillEditor theme="snow" toolbar="essential" placeholder="commentary" @ready="onReady" @textChange="textChange(iGrp, 2)" />
            <hr class="subline" />
            <QuillEditor theme="snow" toolbar="essential" placeholder="datestamp" @ready="onReady" @textChange="textChange(iGrp, 3)" />
        </div>
    </div>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted } from "vue";
import { QuillEditor, Quill } from "@vueup/vue-quill";
import "@vueup/vue-quill/dist/vue-quill.snow.css";
import "@vueup/vue-quill/dist/vue-quill.bubble.css";
import { jsonEntityHTML, jsonEntityTEXT } from "../../share/EntityType";
import { itemName, itemKind } from "../../share/share";

export default defineComponent({
    name: "EntrySIF",
    components: {
        QuillEditor,
    },
    setup() {
        const label = "SIF:";
        const hint = "list of [xpath(list), definition, commentary, datestamp]";
        let icon = ref("chevron-down");
        let thisQuills: Quill[] = [];
        let idxQuill = 0;
        let visEditor = ref(false);
        let editorCount = ref(1);
        let flagSet: boolean = true;

        const onReady = (quill: Quill) => {
            thisQuills[idxQuill++] = quill;
        };

        const textChange = (idxGrp: number, idx: number) => {
            if (flagSet) {
                const html = thisQuills[idxGrp * 4 + idx].root.innerHTML; // get html from quill
                const text = thisQuills[idxGrp * 4 + idx].getText(0, 100000); // get text from quill
                switch (idx) {
                    case 0:
                        jsonEntityHTML.SetSIF("html", idxGrp, html, "", "", "");
                        jsonEntityTEXT.SetSIF("", idxGrp, text, "", "", "");
                        break;
                    case 1:
                        jsonEntityHTML.SetSIF("html", idxGrp, "", html, "", "");
                        jsonEntityTEXT.SetSIF("", idxGrp, "", text, "", "");
                        break;
                    case 2:
                        jsonEntityHTML.SetSIF("html", idxGrp, "", "", html, "");
                        jsonEntityTEXT.SetSIF("", idxGrp, "", "", text, "");
                        break;
                    case 3:
                        jsonEntityHTML.SetSIF("html", idxGrp, "", "", "", html);
                        jsonEntityTEXT.SetSIF("", idxGrp, "", "", "", text);
                        break;
                }
            }
        };

        const onToggleVisible = () => {
            visEditor.value = !visEditor.value;
            icon.value = icon.value == "chevron-down" ? "chevron-up" : "chevron-down";
        };

        const onMoreLessClick = (type: string) => {
            switch (type) {
                case "+":
                    {
                        if (jsonEntityTEXT.IsLastSIFEmpty()) {
                            alert("please use available editor(s). if hidden, unfold it")
                            break
                        }

                        // add new OtherStandard element in json
                        jsonEntityHTML.AddSIF();
                        jsonEntityTEXT.AddSIF();

                        editorCount.value++;
                    }
                    break;

                case "-":
                    {
                        if (editorCount.value == 1) {
                            alert("no more editor group to remove")
                            break;
                        }

                        // clear preview
                        idxQuill -= 4;

                        // remove last OtherStandard element in json
                        jsonEntityHTML.RmSIFLast();
                        jsonEntityTEXT.RmSIFLast();

                        editorCount.value--;
                    }
                    break;
                default:
            }
            // console.log('editor count:', editorCount.value)
        };

        onMounted(async () => {
            await new Promise((f) => setTimeout(f, 500));
            flagSet = false

            if (itemName.value.length > 0 && itemKind.value.length > 0) {
                editorCount.value = jsonEntityHTML.SIF.length;
                await new Promise((f) => setTimeout(f, 500));
                for (let i = 0; i < jsonEntityHTML.SIF.length; i++) {
                    const sif = jsonEntityHTML.SIF[i]
                    thisQuills[i * 4 + 0].root.innerHTML = sif.XPath != null ? sif.XPath.join('\n') : ""
                    thisQuills[i * 4 + 1].root.innerHTML = sif.Definition
                    thisQuills[i * 4 + 2].root.innerHTML = sif.Commentary
                    thisQuills[i * 4 + 3].root.innerHTML = sif.Datestamp
                }
            }

            await new Promise((f) => setTimeout(f, 500));
            flagSet = true
        })

        return {
            label,
            hint,
            icon,
            editorCount,
            visEditor,
            textChange,
            onReady,
            onMoreLessClick,
            onToggleVisible,
            jsonEntityTEXT,
        };
    },
});
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
h2 {
    text-align: center;
}
</style>
